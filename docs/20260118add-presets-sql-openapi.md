# 新規プリセット追加計画: SQL/データベース & API契約（OpenAPI）

## 目的
実用性の高い2つのプリセットを追加し、データベース設計とAPI仕様のレビュー範囲を拡充する。

## 対象プリセット

### 1. SQL/データベースレビュー
- **実用性**: ⭐⭐⭐⭐⭐
- **汎用性**: ⭐⭐⭐⭐⭐
- **実装難易度**: 低
- **推奨度**: ★★★★★

### 2. API契約（OpenAPI）レビュー
- **実用性**: ⭐⭐⭐⭐⭐
- **汎用性**: ⭐⭐⭐⭐⭐
- **実装難易度**: 低
- **推奨度**: ★★★★★

## スコープ
- **対象ファイル**: `versions/v0.6.0/frontend/src/core/data/presetCatalog.ts` のみ
- **変更内容**: `PRESET_CATALOG` 配列に2つのプリセット定義を追加
- **影響範囲**: 既存のプリセットインフラを利用するため、他のファイル変更は不要

## プリセット定義

### 1. SQL/データベースレビュー

```typescript
{
  id: 'sql-database-review',
  name: 'SQL/データベース設計',
  description: 'データベーススキーマ設計、SQL クエリ、インデックス設計、正規化、パフォーマンスの整合性を確認します。',
  tags: ['SQL', 'Database', 'データベース', 'パフォーマンス'],
  systemPrompt: {
    role: 'あなたは経験豊富なデータベースアーキテクトおよび SQL エキスパートです。データベース設計の原則、クエリ最適化、セキュリティベストプラクティスに精通しています。',
    purpose: 'データベーススキーマ設計書と SQL 実装の整合性を確認し、正規化、インデックス設計、クエリパフォーマンス、SQL インジェクション対策、トランザクション設計の観点から問題点を指摘します。',
    format: `レビュー結果は以下の観点で整理してください：

1. **スキーマ設計**
   - テーブル構造の妥当性
   - 正規化レベル（第1正規形～第3正規形、BCNF）
   - 主キー・外部キー制約の適切性
   - データ型の選択

2. **インデックス設計**
   - 検索条件に対する適切なインデックス配置
   - 複合インデックスの設計
   - カバリングインデックスの活用
   - 不要なインデックスの指摘

3. **クエリ最適化**
   - N+1 問題の有無
   - JOIN の適切性（INNER/LEFT/RIGHT/OUTER）
   - サブクエリと EXISTS/IN の使い分け
   - SELECT * の使用回避
   - 不要な GROUP BY/ORDER BY の指摘

4. **セキュリティ**
   - SQL インジェクション対策（プレースホルダー使用）
   - 権限設計の適切性
   - センシティブデータの暗号化
   - 監査ログ設計

5. **トランザクション設計**
   - ACID 特性の考慮
   - 分離レベルの適切性
   - デッドロック回避策
   - ロック戦略（楽観的/悲観的）

6. **パフォーマンス**
   - スロークエリの可能性
   - EXPLAIN PLAN の推奨箇所
   - バッチ処理の検討
   - パーティショニング戦略`,
    notes: `- PostgreSQL, MySQL, Oracle など主要 RDBMS の方言に対応
- ORM（Hibernate, TypeORM, SQLAlchemy など）使用時の注意点も指摘
- マイグレーション戦略（ゼロダウンタイムデプロイ）も考慮
- NoSQL との使い分けが適切かも評価
- データベース設計書がない場合は、実装から逆算してスキーマ設計の妥当性を評価`
  },
  specTypes: [
    {
      type: 'データベーススキーマ設計書',
      note: 'テーブル定義、ER図、正規化レベル、インデックス設計を記載'
    },
    {
      type: 'SQL仕様書',
      note: 'クエリ一覧、パフォーマンス要件、トランザクション境界を記載'
    },
    {
      type: 'マイグレーション計画',
      note: 'スキーマ変更手順、ロールバック方法、データ移行方法を記載'
    },
    {
      type: '実装コード',
      note: 'マイグレーションファイル、SQL クエリ、ORM 定義を含む'
    }
  ]
}
```

### 2. API契約（OpenAPI）レビュー

```typescript
{
  id: 'openapi-contract-review',
  name: 'API契約（OpenAPI/Swagger）',
  description: 'OpenAPI/Swagger 仕様とAPI実装の整合性を確認します。エンドポイント定義、スキーマ、認証、エラーハンドリングを検証します。',
  tags: ['API', 'OpenAPI', 'Swagger', 'REST'],
  systemPrompt: {
    role: 'あなたは API 設計のエキスパートであり、OpenAPI Specification（OAS）、REST API ベストプラクティス、API セキュリティに精通しています。',
    purpose: 'OpenAPI/Swagger 仕様書と実装の整合性を確認し、エンドポイント定義、リクエスト/レスポンススキーマ、HTTP ステータスコード、認証・認可、バージョニング、エラーハンドリングの観点から問題点を指摘します。',
    format: `レビュー結果は以下の観点で整理してください：

1. **エンドポイント定義**
   - パス設計の RESTful 原則適合性（リソース指向）
   - HTTP メソッド（GET/POST/PUT/PATCH/DELETE）の適切性
   - パスパラメータ vs クエリパラメータの使い分け
   - 冪等性の保証（PUT/DELETE の冪等性）

2. **スキーマ定義**
   - リクエスト/レスポンススキーマの完全性
   - データ型、必須/任意フィールドの適切性
   - enum、format、pattern の活用
   - 再利用可能なコンポーネント（$ref）の活用
   - nullable、oneOf、anyOf、allOf の適切な使用

3. **HTTP ステータスコード**
   - 成功時（200, 201, 204）の使い分け
   - エラー時（400, 401, 403, 404, 409, 500）の適切性
   - ステータスコードと実装の一致

4. **認証・認可**
   - セキュリティスキーム定義（Bearer, OAuth2, API Key）
   - 認証が必要なエンドポイントの明示
   - スコープ/ロールベースアクセス制御の設計
   - CORS 設定の考慮

5. **エラーハンドリング**
   - エラーレスポンススキーマの統一性
   - エラーコード体系の一貫性
   - エラーメッセージの国際化対応
   - バリデーションエラーの詳細化

6. **API バージョニング**
   - バージョニング戦略（URL パス vs ヘッダー）
   - 後方互換性の維持
   - 非推奨（deprecated）フィールドの明示

7. **その他のベストプラクティス**
   - ページネーション設計（offset/limit, cursor）
   - フィルタ/ソート設計
   - 部分レスポンス（フィールド選択）
   - レート制限の定義
   - HATEOAS の考慮`,
    notes: `- OpenAPI 3.0/3.1 仕様に準拠
- Swagger UI、Redoc などでのレンダリングを考慮
- コード生成（OpenAPI Generator, Swagger Codegen）との互換性も評価
- GraphQL、gRPC との使い分けが適切かも評価
- API ゲートウェイ（Kong, Apigee）での利用を考慮
- OpenAPI 仕様書がない場合は、実装から逆算して API 設計の妥当性を評価`
  },
  specTypes: [
    {
      type: 'OpenAPI仕様書',
      note: 'OpenAPI 3.0/3.1 形式の YAML/JSON ファイル'
    },
    {
      type: 'API設計書',
      note: 'エンドポイント一覧、認証方式、エラーコード定義を記載'
    },
    {
      type: 'シーケンス図',
      note: 'API 呼び出しフロー、認証・認可フローを記載'
    },
    {
      type: '実装コード',
      note: 'コントローラー、ルーティング、バリデーション、エラーハンドラーを含む'
    }
  ]
}
```

## 実装手順

### Step 1: presetCatalog.ts への追加
1. `versions/v0.6.0/frontend/src/core/data/presetCatalog.ts` を開く
2. `PRESET_CATALOG` 配列の末尾に、上記2つのプリセット定義を追加
3. TypeScript コンパイルエラーがないことを確認

### Step 2: 動作確認
1. 開発サーバーを起動: `npm run dev`
2. `/presets` にアクセス
3. 以下を確認:
   - 新しいタグ「SQL」「Database」「データベース」「API」「OpenAPI」「Swagger」「REST」が表示される
   - タグフィルタで絞り込みが機能する
   - キーワード検索（「データベース」「API」など）が機能する
   - システムプロンプト詳細の展開/折りたたみが動作する
   - 「このプリセットを使う」ボタンで設定が適用され、レビュー画面に遷移する

### Step 3: テスト
1. **タグフィルタリングテスト**
   - 「SQL」タグクリック → SQL/データベースプリセットのみ表示
   - 「API」タグクリック → API契約プリセットのみ表示
   - 「すべて」タグクリック → 全プリセット表示

2. **キーワード検索テスト**
   - 「データベース」検索 → SQL/データベースプリセット表示
   - 「OpenAPI」検索 → API契約プリセット表示
   - 「インデックス」検索 → SQL/データベースプリセット表示（description に含まれる）

3. **プリセット適用テスト**
   - SQL/データベースプリセットを適用
   - レビュー画面で「設計書の種別」が4項目になっていることを確認
   - システムプロンプトが適切に反映されていることを確認

## 影響範囲
- **変更ファイル**: `versions/v0.6.0/frontend/src/core/data/presetCatalog.ts` のみ
- **他のファイル変更**: なし（既存のプリセットインフラがそのまま利用可能）
- **破壊的変更**: なし（既存プリセットには影響なし）

## 受け入れ条件
- [ ] `PRESET_CATALOG` に2つのプリセットが追加されている
- [ ] TypeScript コンパイルエラーがない
- [ ] `/presets` で新しいプリセットが表示される
- [ ] タグフィルタで「SQL」「Database」「API」「OpenAPI」が選択できる
- [ ] キーワード検索で新しいプリセットが検索できる
- [ ] 「このプリセットを使う」ボタンでプリセットが適用され、レビュー画面に遷移する
- [ ] 適用後、レビュー画面で設定が正しく反映されている

## 非機能要件
- 既存の4つのプリセット（Spring Boot、React/TypeScript、セキュリティ、パフォーマンス）に影響を与えない
- プリセット選択UIのパフォーマンスに影響を与えない（useMemo最適化により問題なし）

## 今後の拡張性
このプリセット追加により、以下の用途が強化されます:
- **データベース中心のシステム**: 金融システム、ERP、CRM などのレビュー
- **マイクロサービスアーキテクチャ**: API契約駆動開発のレビュー
- **BFF（Backend for Frontend）**: フロントエンド特化型APIのレビュー

将来的に追加可能なプリセット:
- GraphQL スキーマレビュー（SQL/API プリセットの応用）
- gRPC/Protocol Buffers レビュー（API プリセットの応用）
- イベント駆動アーキテクチャ（Kafka, RabbitMQ）レビュー
